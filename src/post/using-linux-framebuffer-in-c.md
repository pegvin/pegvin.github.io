---
title Using Linux Framebuffer in C
date 18th Sep, 2024
last_modified_at 06/12/2024
---
The Linux Framebuffer is a device file located at `/dev/fb0`,
which allows you to display pixels on the screen while hiding
away all the nitty gritty details about the hardware (which is
pretty much the whole point of a kernel).

Start by opening the Framebuffer device file using [`open`](https://www.man7.org/linux/man-pages/man2/open.2.html)
function and checking for negative values.
```c
int fb = open("/dev/fb0", O_RDWR);
if (fb < 0) {
	printf("Failed to open '/dev/fb0'\n");
	return 1;
}
```
Make sure you don't forget including `fcntl.h` and `unistd.h` headers.

Then you can use [`ioctl`](https://man7.org/linux/man-pages/man2/ioctl.2.html)
function get information about the Framebuffer, like width, height &
bits per pixel and print the information to console.
```c
struct fb_var_screeninfo vinfo;
ioctl(fb, FBIOGET_VSCREENINFO, &vinfo);

int width = vinfo.xres;
int height = vinfo.yres;
int bits_pp = vinfo.bits_per_pixel;
int bytes_pp = bits_pp / 8;
long int bytes_total = width * height * bytes_pp;

printf("%dx%d - %d bits per pixel (%d bytes)\n", width, height, bits_pp, bytes_pp);
````
Once again, don't forget to include `linux/fb.h` and `sys/ioctl.h` headers.
Compiling and running the program so far should output:
```
$ gcc -Wall -Wextra -pedantic main.c -o ./loonix_fb
$ ./loonix_fb
1920x1080 - 32 bits per pixel (4 bytes)
```
*Edit: As pointed out on [Reddit (by u/thommyh)](https://www.reddit.com/r/C_Programming/comments/1gy3yvf/comment/lymcusq/),
`bits_pp / 8` will yield wrong results for cases where bits per pixel is `15`
since in C the resultant value is rounded towards zero (i.e. fractional part
is discard, also called "truncation").  Instead it is recommended to use
`(bits_pp + 7) / 8`*

Now you can just map the screen to a memory region using [`mmap`](https://www.man7.org/linux/man-pages/man2/mmap.2.html)
to read/write to the Framebuffer much easily.
```c
unsigned char* fbData = mmap(
	0, bytes_total, PROT_READ | PROT_WRITE,
	MAP_SHARED, fb, (off_t)0
);
```
Make sure to include `sys/mman.h` header.

Finally you can start writing to the memory, In this simple example
I am simply repeatedly setting each each pixel component of all the
pixels to a random value generated by [`rand`](https://man7.org/linux/man-pages/man3/srand.3.html)
function.
```c
while (1) {
	for (long int i = 0; i < bytes_total; i++) {
		fbData[i] = rand();
	}
}
```
And obviously don't forget to include `stdlib.h` header.

After you are done using the Framebuffer, make sure you unmap
the mapped memory `fbData` and close the file descriptor `fb`.
```c
munmap(fbData, bytes_total);
close(fb);
```

So finally Compiling and running the program will result in a
screen full of absolute mess.

![Example of writing to Framebuffer](/media/linux-framebuffer.gif)

You can find more in-depth info about Linux Framebuffers at the
official Linux kernel docs: <https://www.kernel.org/doc/html/latest/fb/index.html>.
